---
title: 图论专题 - 二分图 - 二分图判定(染色法)
tags: 图论,二分图,模板
grammar_cjkRuby: true
---

```cpp
/**  \二分图判断，染色法，
 * 注意无向边,临界表
 * 任意找一个未染色的点A，染色，然后给所有相邻的点染上相反的颜色
 * 不是二分图的充要条件 ： 如果相邻的点已经染了色，而且颜色跟点A相同
 * 序号1 ～ n 注意初始化
 */
const int SIZE_V = 20000+500;
const int SIZE_E = 100000+500;
struct edge_t{
    int node;
    int next;
}Edge[SIZE_E];
int Ecnt ; // = 0
int Ver[SIZE_V];
void mkEdge( int a,int b ){
    Edge[Ecnt].node = b;
    Edge[Ecnt].next = Ver[a];
    Ver[a] = Ecnt++;

    Edge[Ecnt].node = a;
    Edge[Ecnt].next = Ver[b];
    Ver[b] = Ecnt++;
}
void init_Graph(){
    Ecnt = 1;
    CLEAR(Ver);
}

int color[SIZE_V];
bool BFS( int s,int n ){
    queue<int> que;
    que.push(s);
    color[s] = 1;
    while( !que.empty() ){
        int u = que.front(); que.pop();
        for (int next = Ver[u];next;next=Edge[next].next){
            int v = Edge[next].node;
            if( color[v] == -1 ){
                color[v] = !color[u];
                que.push(v);
            }
            if ( color[v] == color[u] )
                return false;
        }
    }
    return true;
}
bool just_Bipartite_Graph( int n ){
    for ( int i = 1;i <= n;++i )
        if ( color[i] == -1 && BFS(i,n) == 0 )
            return false;
    return true;
}
void init(){
    memset(color,-1,sizeof(color));
}
```